{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Luwra is a header-only library, which means that nothing has to be compiled in order to use it. Simply clone the repository or download it and extract it to a directory of your preference. For your application to be able to reach the lib/luwra.hpp header file, you must add /path/to/luwra/lib to the list of include paths. With Clang and GCC that is done using the -I/path/to/luwra/lib command-line parameter. Now you can simply #include <luwra.hpp> in your C++ files and start using Luwra. Integration This library does not provide a standalone version of Lua nor does it isolate its features. This means that all functions and classes can operate on lua_State (or the alias State ). Doing this allows you to integrate Luwra however you like. Nevertheless, you must have a version of Lua installed. Luwra will include the necessary header files, but it can't link against the Lua library itself. Reference Manual A reference manual exists here .","title":"Home"},{"location":"#installation","text":"Luwra is a header-only library, which means that nothing has to be compiled in order to use it. Simply clone the repository or download it and extract it to a directory of your preference. For your application to be able to reach the lib/luwra.hpp header file, you must add /path/to/luwra/lib to the list of include paths. With Clang and GCC that is done using the -I/path/to/luwra/lib command-line parameter. Now you can simply #include <luwra.hpp> in your C++ files and start using Luwra.","title":"Installation"},{"location":"#integration","text":"This library does not provide a standalone version of Lua nor does it isolate its features. This means that all functions and classes can operate on lua_State (or the alias State ). Doing this allows you to integrate Luwra however you like. Nevertheless, you must have a version of Lua installed. Luwra will include the necessary header files, but it can't link against the Lua library itself.","title":"Integration"},{"location":"#reference-manual","text":"A reference manual exists here .","title":"Reference Manual"},{"location":"stack/","text":"Stack Interaction Luwra provides several easy ways to interact with the Lua virtual stack. Pushing Values To get values onto the stack, use push . luwra::push(state, 1337); luwra::push(state, 13.37); luwra::push(state, \"Hello World\"); luwra::push(state, MyUserType(\"Hello\", 5)); You can also push them all at once. luwra::push(state, 1337, 13.37, \"Hello World\", MyUserType(\"Hello\", 5)); Reading Values Reading values works with read . Assuming the stack has been prepared as it has been in the previous section, you can extract the values like so. int i = luwra::read<int>(state, 1); double d = luwra::read<double>(state, 2); std::string s = luwra::read<std::string>(state, 3); MyUserType& u = luwra::read<MyUserType>(state, 4); You can also let C++ infer the types for you. int i = luwra::read(state, 1); double d = luwra::read(state, 2); std::string s = luwra::read(state, 3); MyUserType& u = luwra::read(state, 4); Note: Type inference does not work with every compiler. Particularly GCC before version 4.9.2 is affected by this problem. Invoke Callables with Stack Values apply is a function that retrieves values from the stack in order to invoke a given Callable . The types of values on the stack are deduced from the parameter types to the Callable . std::string substring(const std::string& str, size_t len) { return str.substr(0, len); } luwra::push(state, \"Hello World\"); luwra::push(state, 5); // Retrieve values and invoke 'substring'. std::string result = luwra::apply(state, 1, substring); // This is essentially equal to the following. std::string result = substring(luwra::read(state, 1), luwra::read(state, 2)); // You can also provide your own arguments before the stack values. std::string result = luwra::apply(state, 2, substring, \"My Own String\"); // Alternatively std::string result = substring(\"My Own String\", luwra::read(state, 2)); If you wish to return the result of your function to the stack, simply use map . luwra::map(state, 1, substring); std::string result = luwra::read(state, -1); You can also provide function objects or lambdas to apply and map . std::string result = luwra::apply(state, 1, [](const std::string& str, size_t len) { return str.substr(0, len); });","title":"Stack Interaction"},{"location":"stack/#stack-interaction","text":"Luwra provides several easy ways to interact with the Lua virtual stack.","title":"Stack Interaction"},{"location":"stack/#pushing-values","text":"To get values onto the stack, use push . luwra::push(state, 1337); luwra::push(state, 13.37); luwra::push(state, \"Hello World\"); luwra::push(state, MyUserType(\"Hello\", 5)); You can also push them all at once. luwra::push(state, 1337, 13.37, \"Hello World\", MyUserType(\"Hello\", 5));","title":"Pushing Values"},{"location":"stack/#reading-values","text":"Reading values works with read . Assuming the stack has been prepared as it has been in the previous section, you can extract the values like so. int i = luwra::read<int>(state, 1); double d = luwra::read<double>(state, 2); std::string s = luwra::read<std::string>(state, 3); MyUserType& u = luwra::read<MyUserType>(state, 4); You can also let C++ infer the types for you. int i = luwra::read(state, 1); double d = luwra::read(state, 2); std::string s = luwra::read(state, 3); MyUserType& u = luwra::read(state, 4); Note: Type inference does not work with every compiler. Particularly GCC before version 4.9.2 is affected by this problem.","title":"Reading Values"},{"location":"stack/#invoke-callables-with-stack-values","text":"apply is a function that retrieves values from the stack in order to invoke a given Callable . The types of values on the stack are deduced from the parameter types to the Callable . std::string substring(const std::string& str, size_t len) { return str.substr(0, len); } luwra::push(state, \"Hello World\"); luwra::push(state, 5); // Retrieve values and invoke 'substring'. std::string result = luwra::apply(state, 1, substring); // This is essentially equal to the following. std::string result = substring(luwra::read(state, 1), luwra::read(state, 2)); // You can also provide your own arguments before the stack values. std::string result = luwra::apply(state, 2, substring, \"My Own String\"); // Alternatively std::string result = substring(\"My Own String\", luwra::read(state, 2)); If you wish to return the result of your function to the stack, simply use map . luwra::map(state, 1, substring); std::string result = luwra::read(state, -1); You can also provide function objects or lambdas to apply and map . std::string result = luwra::apply(state, 1, [](const std::string& str, size_t len) { return str.substr(0, len); });","title":"Invoke Callables with Stack Values"},{"location":"state/","text":"State Wrapper Document me, please.","title":"State Wrapper"},{"location":"state/#state-wrapper","text":"Document me, please.","title":"State Wrapper"},{"location":"usertypes/","text":"User Types A user type is a collection of class members bundled into a metatable. In order to use all class members, one must register the type's metatable in Lua's registry. The following examples work on this class: struct Point { double x, y; Point(double x, double y): x(x), y(y) { std::cout << \"Construct Point(\" << x << \", \" << y << \")\" << std::endl; } ~Point() { std::cout << \"Destruct Point(\" << x << \", \" << y << \")\" << std::endl; } void scale(double f) { x *= f; y *= f; } std::string __tostring() { return \"<Point(\" + std::to_string(x) + \", \" + std::to_string(y) + \")>\"; } }; Register User Type with Constructor registerUserType<UserType(CtorArgs...)> allows you to register a metatable for UserType and a constructor for it with the parameter types CtorArgs... in the global namespace. By default, the function generates a garbage-collector hook and a string representation function. If you add a __gc or __tostring meta method to your type, these auto-generated functions will be overridden. luwra::registerUserType<Point(double, double)>( lua, // Constructor name \"Point\", // Methods need to be declared here { LUWRA_MEMBER(Point, scale), LUWRA_MEMBER(Point, x), LUWRA_MEMBER(Point, y) }, // Meta methods may be registered aswell { LUWRA_MEMBER(Point, __tostring) } ); The LUWRA_MEMBER macro generates an expression which initializes a key-value association. LUWRA_MEMBER(Point, scale) == {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)} Pushable is constructible using every pushable type, which makes it convenient to add other types of fields: luwra::registerUserType<Point(double, double)>( lua, // Constructor name \"Point\", // Methods need to be declared here { {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)}, {\"x\", LUWRA_WRAP_MEMBER(Point, x)}, {\"y\", LUWRA_WRAP_MEMBER(Point, y)}, {\"magic\", luwra::MemberMap { {\"number\", 1337}, {\"string\", \"Hello World\"} }} }, // Meta methods may be registered aswell { {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)} } ); Register User Type without Constructor To register only the metatable associated with a user type, simply omit the constructor parameters and name from the call to registerUserType . luwra::registerUserType<Point>( lua, // Methods need to be declared here { {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)}, {\"x\", LUWRA_WRAP_MEMBER(Point, x)}, {\"y\", LUWRA_WRAP_MEMBER(Point, y)}, {\"magic\", luwra::MemberMap { {\"number\", 1337}, {\"string\", \"Hello World\"} }} }, // Meta methods may be registered aswell { {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)} } ); It is still possible to provide a constructor using the LUWRA_WRAP_CONSTRUCTOR macro: lua_CFunction ctor = LUWRA_WRAP_CONSTRUCTOR(Point, double, double); luwra::setGlobal(lua, \"Point\", ctor); Usage in Lua After you have registered your user type using one of the given methods, you can start using it in Lua: -- Instantiate 'Point' local point = Point(13, 37) -- Invoke 'scale' method point:scale(1.5) -- Convert to string via '__tostring' meta method print(point) -- Read properties 'x' and 'y' print(point:x(), point:y()) -- Set property 'x' point:x(point.magic.number) Manually constructing a User Type construct provides this functionality. Given the user type and constructor parameters, it will construct the user type on top of the stack: Point& my_point = luwra::construct<Point>(lua, 13.37, 73.31); // Changes on C++ side will be visible in Lua my_point.scale(2); Registry Names When registering the metatable for a user type, an automatically generated name will be used to store it in the registry. When Luwra is used in a single executable or shared library, name collisions should not happen. If your application consists of multiple seperate compiled units, it is highly recommended to prevent name collisions by defining the LUWRA_REGISTRY_PREFIX macro before including the Luwra headers. This macro changes the prefix for auto-generated registry names. #define LUWRA_REGISTRY_PREFIX \"MyProject#\" #include <luwra.hpp> Another way to prevent collisons is to give each user type its individual registry name. This can be done using the LUWRA_DEF_REGISTRY_NAME macro. struct MyUserType { // ... }; LUWRA_DEF_REGISTRY_NAME(MyUserType, \"MyUserType\") This method will not prefix the registry name with the value of LUWRA_REGISTRY_PREFIX . The LUWRA_DEF_REGISTRY_NAME macro has to be used at the root namespace, using it inside a namespace scope will have no effect.","title":"User Types"},{"location":"usertypes/#user-types","text":"A user type is a collection of class members bundled into a metatable. In order to use all class members, one must register the type's metatable in Lua's registry. The following examples work on this class: struct Point { double x, y; Point(double x, double y): x(x), y(y) { std::cout << \"Construct Point(\" << x << \", \" << y << \")\" << std::endl; } ~Point() { std::cout << \"Destruct Point(\" << x << \", \" << y << \")\" << std::endl; } void scale(double f) { x *= f; y *= f; } std::string __tostring() { return \"<Point(\" + std::to_string(x) + \", \" + std::to_string(y) + \")>\"; } };","title":"User Types"},{"location":"usertypes/#register-user-type-with-constructor","text":"registerUserType<UserType(CtorArgs...)> allows you to register a metatable for UserType and a constructor for it with the parameter types CtorArgs... in the global namespace. By default, the function generates a garbage-collector hook and a string representation function. If you add a __gc or __tostring meta method to your type, these auto-generated functions will be overridden. luwra::registerUserType<Point(double, double)>( lua, // Constructor name \"Point\", // Methods need to be declared here { LUWRA_MEMBER(Point, scale), LUWRA_MEMBER(Point, x), LUWRA_MEMBER(Point, y) }, // Meta methods may be registered aswell { LUWRA_MEMBER(Point, __tostring) } ); The LUWRA_MEMBER macro generates an expression which initializes a key-value association. LUWRA_MEMBER(Point, scale) == {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)} Pushable is constructible using every pushable type, which makes it convenient to add other types of fields: luwra::registerUserType<Point(double, double)>( lua, // Constructor name \"Point\", // Methods need to be declared here { {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)}, {\"x\", LUWRA_WRAP_MEMBER(Point, x)}, {\"y\", LUWRA_WRAP_MEMBER(Point, y)}, {\"magic\", luwra::MemberMap { {\"number\", 1337}, {\"string\", \"Hello World\"} }} }, // Meta methods may be registered aswell { {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)} } );","title":"Register User Type with Constructor"},{"location":"usertypes/#register-user-type-without-constructor","text":"To register only the metatable associated with a user type, simply omit the constructor parameters and name from the call to registerUserType . luwra::registerUserType<Point>( lua, // Methods need to be declared here { {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)}, {\"x\", LUWRA_WRAP_MEMBER(Point, x)}, {\"y\", LUWRA_WRAP_MEMBER(Point, y)}, {\"magic\", luwra::MemberMap { {\"number\", 1337}, {\"string\", \"Hello World\"} }} }, // Meta methods may be registered aswell { {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)} } ); It is still possible to provide a constructor using the LUWRA_WRAP_CONSTRUCTOR macro: lua_CFunction ctor = LUWRA_WRAP_CONSTRUCTOR(Point, double, double); luwra::setGlobal(lua, \"Point\", ctor);","title":"Register User Type without Constructor"},{"location":"usertypes/#usage-in-lua","text":"After you have registered your user type using one of the given methods, you can start using it in Lua: -- Instantiate 'Point' local point = Point(13, 37) -- Invoke 'scale' method point:scale(1.5) -- Convert to string via '__tostring' meta method print(point) -- Read properties 'x' and 'y' print(point:x(), point:y()) -- Set property 'x' point:x(point.magic.number)","title":"Usage in Lua"},{"location":"usertypes/#manually-constructing-a-user-type","text":"construct provides this functionality. Given the user type and constructor parameters, it will construct the user type on top of the stack: Point& my_point = luwra::construct<Point>(lua, 13.37, 73.31); // Changes on C++ side will be visible in Lua my_point.scale(2);","title":"Manually constructing a User Type"},{"location":"usertypes/#registry-names","text":"When registering the metatable for a user type, an automatically generated name will be used to store it in the registry. When Luwra is used in a single executable or shared library, name collisions should not happen. If your application consists of multiple seperate compiled units, it is highly recommended to prevent name collisions by defining the LUWRA_REGISTRY_PREFIX macro before including the Luwra headers. This macro changes the prefix for auto-generated registry names. #define LUWRA_REGISTRY_PREFIX \"MyProject#\" #include <luwra.hpp> Another way to prevent collisons is to give each user type its individual registry name. This can be done using the LUWRA_DEF_REGISTRY_NAME macro. struct MyUserType { // ... }; LUWRA_DEF_REGISTRY_NAME(MyUserType, \"MyUserType\") This method will not prefix the registry name with the value of LUWRA_REGISTRY_PREFIX . The LUWRA_DEF_REGISTRY_NAME macro has to be used at the root namespace, using it inside a namespace scope will have no effect.","title":"Registry Names"},{"location":"utilities/","text":"Utilities Document me, please.","title":"Utilities"},{"location":"utilities/#utilities","text":"Document me, please.","title":"Utilities"},{"location":"values/","text":"Values A fundamental part of Luwra is the Value template which acts as a type class. It is used to define read and push behavior for certain types. A type T is considered readable if a function T Value<T>::read(State*, int) exists. The return type of that function need not be T , instead it can be anything that is convertible to T . A type T is considered pushable if a funtion void Value<T>::push(State*, T) exists. In order to avoid unnecessary copying, the second parameter type may also be const T& . Default Implementations Several useful specializations are provided out of the box. C++ type Pushable Readable Lua type bool yes yes boolean signed char yes yes number (integer since 5.3) signed short yes yes number (integer since 5.3) signed int yes yes number (integer since 5.3) signed long int yes yes number (integer since 5.3) signed long long int yes yes number (integer since 5.3) unsigned char yes yes number (integer since 5.3) unsigned short yes yes number (integer since 5.3) unsigned int yes yes number (integer since 5.3) unsigned long int yes yes number (integer since 5.3) unsigned long long int yes yes number (integer since 5.3) float yes yes number double yes yes number long double yes yes number const char* yes yes string std::string yes yes string std::nullptr_t yes yes nil std::vector<T> yes no table std::list<T> yes no table std::map<K, V> yes yes table lua_CFunction yes no function Function yes yes function, table or userdata Table yes yes table Note: Some numeric types have a different size than their matching Lua type - they will be truncated during read or push operations. Arbitrary and User Types Value provides a catch-all generalization for types that do not have a specialization of Value . Although these types are not known to Luwra, they are pushable and readable. Instances of these so-called user types are constructed on the Lua stack as a full userdata . Additionally, a metatable that is specific to the given user type is attached to the userdata. This metatable allows us to check whether a userdata is an instance of a specific user type. push operations always copy or move instances of the user type onto the stack, whereas read operations always reference the user type value on the stack. By default, the metatables that are attached to the user type values are empty. Because of this, they provide no functionality to Lua and are never destructed (underlying storage is just freed). You can change this behavior, read more in the User Types section. Extending Value You can customize the read and push behavior for your own type T . Simply modify the following snippet and insert it outside of any namespace. namespace luwra { template <> struct Value<T> { static inline T read(State* state, int index) { return /* Return the instance of T that you have read at the given index */; } static inline void push(State* state, const T& value) { // Push the given value on top of the stack } }; } Return Values The template ReturnValues extends the push functionality on top of Value by allowing more complex types to be pushed onto the stack. ReturnValues makes it possible to use std::tuple<...> or std::pair<...> as return type of user-provided functions in order to mimic the ability of Lua functions to return multiple values at once. Read and Type Errors Luwra does not handle errors. Instead it delegates the error handling to Lua. See Error Handling in C for more information. It is highly recommended that you use a version of Lua that has been compiled as C++. Doing otherwise might lead to improper stack unwinding in case of an error which causes resources to be leaked, since the calling of destructors is not guaranteed.","title":"Values"},{"location":"values/#values","text":"A fundamental part of Luwra is the Value template which acts as a type class. It is used to define read and push behavior for certain types. A type T is considered readable if a function T Value<T>::read(State*, int) exists. The return type of that function need not be T , instead it can be anything that is convertible to T . A type T is considered pushable if a funtion void Value<T>::push(State*, T) exists. In order to avoid unnecessary copying, the second parameter type may also be const T& .","title":"Values"},{"location":"values/#default-implementations","text":"Several useful specializations are provided out of the box. C++ type Pushable Readable Lua type bool yes yes boolean signed char yes yes number (integer since 5.3) signed short yes yes number (integer since 5.3) signed int yes yes number (integer since 5.3) signed long int yes yes number (integer since 5.3) signed long long int yes yes number (integer since 5.3) unsigned char yes yes number (integer since 5.3) unsigned short yes yes number (integer since 5.3) unsigned int yes yes number (integer since 5.3) unsigned long int yes yes number (integer since 5.3) unsigned long long int yes yes number (integer since 5.3) float yes yes number double yes yes number long double yes yes number const char* yes yes string std::string yes yes string std::nullptr_t yes yes nil std::vector<T> yes no table std::list<T> yes no table std::map<K, V> yes yes table lua_CFunction yes no function Function yes yes function, table or userdata Table yes yes table Note: Some numeric types have a different size than their matching Lua type - they will be truncated during read or push operations.","title":"Default Implementations"},{"location":"values/#arbitrary-and-user-types","text":"Value provides a catch-all generalization for types that do not have a specialization of Value . Although these types are not known to Luwra, they are pushable and readable. Instances of these so-called user types are constructed on the Lua stack as a full userdata . Additionally, a metatable that is specific to the given user type is attached to the userdata. This metatable allows us to check whether a userdata is an instance of a specific user type. push operations always copy or move instances of the user type onto the stack, whereas read operations always reference the user type value on the stack. By default, the metatables that are attached to the user type values are empty. Because of this, they provide no functionality to Lua and are never destructed (underlying storage is just freed). You can change this behavior, read more in the User Types section.","title":"Arbitrary and User Types"},{"location":"values/#extending-value","text":"You can customize the read and push behavior for your own type T . Simply modify the following snippet and insert it outside of any namespace. namespace luwra { template <> struct Value<T> { static inline T read(State* state, int index) { return /* Return the instance of T that you have read at the given index */; } static inline void push(State* state, const T& value) { // Push the given value on top of the stack } }; }","title":"Extending Value"},{"location":"values/#return-values","text":"The template ReturnValues extends the push functionality on top of Value by allowing more complex types to be pushed onto the stack. ReturnValues makes it possible to use std::tuple<...> or std::pair<...> as return type of user-provided functions in order to mimic the ability of Lua functions to return multiple values at once.","title":"Return Values"},{"location":"values/#read-and-type-errors","text":"Luwra does not handle errors. Instead it delegates the error handling to Lua. See Error Handling in C for more information. It is highly recommended that you use a version of Lua that has been compiled as C++. Doing otherwise might lead to improper stack unwinding in case of an error which causes resources to be leaked, since the calling of destructors is not guaranteed.","title":"Read and Type Errors"},{"location":"wrapping/","text":"Wrapping Luwra provides a simple way to generate Lua C functions from functions and class members like methods and accessors using the LUWRA_WRAP macro. These kind of C functions are useful, because they work just like regular Lua functions within the Lua virtual machine. Registering these functions is the most straightforward way of providing the functionality of your application to Lua. Functions When wrapping functions, one must consider that all parameter types must be read from the stack and the return type must be pushed onto the stack. Example Lets assume you want to make the following function available in Lua. int my_function(const char* a, int b); First, you must generate a Lua C function . One utilizes the LUWRA_WRAP macro for this. lua_CFunction cfun = LUWRA_WRAP(my_function); Note: Do not provide the address of your function (e.g. &my_function ) to any wrapping macro. The macro will take care of this itself. You must provide only the name of the function. Once you have the C function, you can register it in the global namespace. luwra::setGlobal(lua, \"my_function\", cfun); Invoking the function in Lua is fairly straightforward. print(my_function(\"Hello World\", 1337)) Performance C functions are dynamically created at compile-time. All of the functions involved in wrapping are marked as inline , which means modern compilers produce wrapper functions with zero overhead, when optimization is turned on. For the example above, the resulting code would look similiar to the following. int cfun(lua_State* state) { lua_pushinteger( state, my_function( luaL_checkstring(state, 1), luaL_checkinteger(state, 2) ) ); return 1; } Class Members Although a little trickier, it is also possible to turn C++ field accessors and methods into Lua C functions . The resulting Lua functions expect the first (or self ) parameter to be an instance of the type which the wrapped field or method belongs to. Note: Before you wrap fields and methods manually, you might want to take a look at the User Types section. Example This example will operate on the following structure. struct Point { double x, y; // ... void scale(double f) { x *= f; y *= f; } }; Wrapping field accessors and methods works similar to wrapping functions. lua_CFunction cfun_x = LUWRA_WRAP_MEMBER(Point, x), cfun_y = LUWRA_WRAP_MEMBER(Point, y), cfun_scale = LUWRA_WRAP_MEMBER(Point, scale); // Register in global namespace luwra::setGlobal(lua, \"x\", cfun_x); luwra::setGlobal(lua, \"y\", cfun_y); luwra::setGlobal(lua, \"scale\", cfun_scale); Note: In this case, it is also possible to use LUWRA_WRAP to generate the C functions. The usage of LUWRA_WRAP_MEMBER is only required when working with inherited members, since it is impossible for the LUWRA_WRAP macro to be aware of inherited members. For example, if you are trying to wrap a member B::foo where foo is an inherited member of class A which B derives from, then LUWRA_WRAP(B::foo) would generate a function which is only applicable on instances of A . But LUWRA_WRAP_MEMBER(B, foo) generates a function that can only be applied to instances of B . Usage in Lua is analogous to function usage. -- Instantiate 'Point' here, have a look at the User Types section to find out how to do this local my_point = ... -- Access 'x' and 'y' field print(x(my_point), y(my_point)) -- Set 'x' and 'y' field x(my_point, 13.37) y(my_point, 73.31) -- Invoke 'scale' method scale(my_point, 2)","title":"Wrapping"},{"location":"wrapping/#wrapping","text":"Luwra provides a simple way to generate Lua C functions from functions and class members like methods and accessors using the LUWRA_WRAP macro. These kind of C functions are useful, because they work just like regular Lua functions within the Lua virtual machine. Registering these functions is the most straightforward way of providing the functionality of your application to Lua.","title":"Wrapping"},{"location":"wrapping/#functions","text":"When wrapping functions, one must consider that all parameter types must be read from the stack and the return type must be pushed onto the stack.","title":"Functions"},{"location":"wrapping/#example","text":"Lets assume you want to make the following function available in Lua. int my_function(const char* a, int b); First, you must generate a Lua C function . One utilizes the LUWRA_WRAP macro for this. lua_CFunction cfun = LUWRA_WRAP(my_function); Note: Do not provide the address of your function (e.g. &my_function ) to any wrapping macro. The macro will take care of this itself. You must provide only the name of the function. Once you have the C function, you can register it in the global namespace. luwra::setGlobal(lua, \"my_function\", cfun); Invoking the function in Lua is fairly straightforward. print(my_function(\"Hello World\", 1337))","title":"Example"},{"location":"wrapping/#performance","text":"C functions are dynamically created at compile-time. All of the functions involved in wrapping are marked as inline , which means modern compilers produce wrapper functions with zero overhead, when optimization is turned on. For the example above, the resulting code would look similiar to the following. int cfun(lua_State* state) { lua_pushinteger( state, my_function( luaL_checkstring(state, 1), luaL_checkinteger(state, 2) ) ); return 1; }","title":"Performance"},{"location":"wrapping/#class-members","text":"Although a little trickier, it is also possible to turn C++ field accessors and methods into Lua C functions . The resulting Lua functions expect the first (or self ) parameter to be an instance of the type which the wrapped field or method belongs to. Note: Before you wrap fields and methods manually, you might want to take a look at the User Types section.","title":"Class Members"},{"location":"wrapping/#example_1","text":"This example will operate on the following structure. struct Point { double x, y; // ... void scale(double f) { x *= f; y *= f; } }; Wrapping field accessors and methods works similar to wrapping functions. lua_CFunction cfun_x = LUWRA_WRAP_MEMBER(Point, x), cfun_y = LUWRA_WRAP_MEMBER(Point, y), cfun_scale = LUWRA_WRAP_MEMBER(Point, scale); // Register in global namespace luwra::setGlobal(lua, \"x\", cfun_x); luwra::setGlobal(lua, \"y\", cfun_y); luwra::setGlobal(lua, \"scale\", cfun_scale); Note: In this case, it is also possible to use LUWRA_WRAP to generate the C functions. The usage of LUWRA_WRAP_MEMBER is only required when working with inherited members, since it is impossible for the LUWRA_WRAP macro to be aware of inherited members. For example, if you are trying to wrap a member B::foo where foo is an inherited member of class A which B derives from, then LUWRA_WRAP(B::foo) would generate a function which is only applicable on instances of A . But LUWRA_WRAP_MEMBER(B, foo) generates a function that can only be applied to instances of B . Usage in Lua is analogous to function usage. -- Instantiate 'Point' here, have a look at the User Types section to find out how to do this local my_point = ... -- Access 'x' and 'y' field print(x(my_point), y(my_point)) -- Set 'x' and 'y' field x(my_point, 13.37) y(my_point, 73.31) -- Invoke 'scale' method scale(my_point, 2)","title":"Example"}]}